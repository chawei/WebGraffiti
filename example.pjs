
Integrator scaleInt;

void setup(){
  size(1200,800);
  
  scaleInt = new Integrator(1, 2, 0.017);
 
  smooth();
  
}

float designateWidth = 500;
float designateHeight = 30;

void draw(){
  
  if(scaleInt!=null){
    if(scaleInt.stage==3){
      background(255);
      drawFreehandRect(width/2-designateWidth/2, height/2-designateHeight/2, designateWidth,designateHeight);
      
      scaleInt = null;
    }
    else{
      background(255);
      scaleInt.update();
      
      drawFreehandEllipse(width/2, height/2, map(scaleInt.value, 0, 1, 1, 2)*designateWidth, map(scaleInt.value, 0, 1, 1, 7)*designateHeight);

    }
  }
 
}

ArrayList dots = new ArrayList();


class Point{
  float x, y;
  Point(float x, float y){
    this.x = x;
    this.y = y;
  }
}

void drawFreehandEllipse(float x, float y, float w, float h){
  
  float currentAngle = 0;

  int totalDots = floor( (w+h)/40 );
  if(totalDots<5)
    totalDots = 5;
  
  float angleGap = 2*PI/totalDots;
    
  dots.clear();
  
  for(int i=0; i<totalDots; i++){
    Point p = new Point( x+cos(currentAngle)*w/2*(1+random(0.1)), y+sin(currentAngle)*h/2*(1+random(0.1)) );
    currentAngle+=angleGap;
    dots.add(p);
  }
  
  for(int j=0; j<dots.size(); j++){
    Point p1,p2,p3,p4;
    p1 = (Point) dots.get(j);
    if( j==dots.size()-3){
      p2 = (Point) dots.get(j+1);
      p3 = (Point) dots.get(j+2);
      p4 = (Point) dots.get(0);
    }
    else if(j==dots.size()-2){
      p2 = (Point) dots.get(j+1);
      p3 = (Point) dots.get(0);
      p4 = (Point) dots.get(1);
    }
    else if(j==dots.size()-1){
      p2 = (Point) dots.get(0);
      p3 = (Point) dots.get(1);
      p4 = (Point) dots.get(2);
    }
    else{
      p2 = (Point) dots.get(j+1);
      p3 = (Point) dots.get(j+2);
      p4 = (Point) dots.get(j+3);
    }
    curve(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y);
    
  }
}

void drawFreehandArc(float x, float y, float w, float h, float start, float stop){

  float currentAngle = start;
  
  beginShape();
  
  while(currentAngle<stop){
    float randomX = x + cos(currentAngle) * (1+random(0.1)) * w;
    float randomY = y + sin(currentAngle) * (1+random(0.1)) * h;
    vertex( randomX, randomY);
    currentAngle+=PI/20;
  }
  
  endShape();
}

void drawFreehandRect(float x, float y, float w, float h){

  float gap = 2;
  float freeFactor = 0.2;
  stroke(color(33,33,33));
    
  beginShape();
  vertex(x,y);  

  float currentX = x;
  float currentY = y;
  
	   // MOUTH
	// TOP 
	while( currentX<(x+w) ){
		float randomX = random(1)*gap;
		float randomY = random(1)>0.5 ? random(1) : -1*random(1);
		currentX += randomX;
		currentY += randomY*freeFactor;
		vertex( currentX, currentY);
	}
	// RIGHT
	while( currentY<(y+h) ){
		float randomY = random(1)*gap;
		float randomX = random(1)>0.5 ? random(1) : -1*random(1);
		currentX += randomX*freeFactor;
		currentY += randomY;
		vertex( currentX, currentY);
	}
	// BOTTOM
	while( currentX>x ){
		float randomX = -1*random(1)*gap;
		float randomY = random(1)>0.5 ? random(1) : -1*random(1);
		currentX += randomX;
		currentY += randomY*freeFactor;
		vertex( currentX, currentY);
	}
	// LEFT
	while( currentY>y ){
		float randomY = -1*random(1)*gap;
		float randomX = random(1)>0.5 ? random(1) : -1*random(1);
		currentX += randomX*freeFactor;
		currentY += randomY;
		vertex( currentX, currentY);
	}
  endShape(CLOSE);
  
}


void mouseClicked() {
  scaleInt = new Integrator(1, 2, 0.017); 
}


class Integrator {

  final float ATTRACTION = 0.2f;

  float value;

  int peakTime = 30;
  int yawnTime = peakTime+6;
  
  float attraction = ATTRACTION;
  boolean targeting;
  float target;
 
  float startVel;
  
  int timer = 0;
  int yawnInterval = 20; 
  int yawnTimer = 0;

  int stage;
  
  Integrator() { }


  Integrator(float value) {
    this.value = value;
  }

  Integrator(float value, float startVel, float attraction) {
    this.value = 1;
    this.startVel = startVel;
    this.attraction = attraction;
    this.timer = 0;
    this.yawnTimer = 0;
    this.stage = 0;
   
  }

  void set(float v) {
    value = v;
  }

  void update() {
    
    float tmpValue = 0;
    
    switch(stage){
     
      case 0:
        value = curveValue(timer-peakTime, peakTime);
        timer++;
        if(value==1)
          stage = 1;
        break;
        
      case 1:
        timer++;
        if(timer==yawnTime)
          stage = 2;
        break;
    
      case 2:
        value = curveValue(timer-yawnTime,peakTime);
        timer++; 
        if(value==0)
          stage = 3;  
        break;


    }
  
  }
  
  float curveValue(int x, int xx){ // x range: -xx to xx, curveValue range: 0 - 1 - 0
    float yValue = -1/pow(xx,2)*pow(x,2) + 1;
    return yValue;
  }

}
